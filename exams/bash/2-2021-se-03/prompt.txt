o p e n f m i . n e t . 3 6 0 0 I N S O A n i m b u s . f c c f . n e t . r o o t . f c c f . n e t . (
2 0 2 1 0 4 1 9 0 1 ; s e r i a l
8 6 4 0 0 ; r e f r e s h
7 2 0 0 ; r e t r y
3 0 2 4 0 0 0 ; e x p i r e
3 6 0 0 ; n e g a t i v e T T L
)
т.е., поредицата от числа се разбива на няколко реда, оградени в обикновенни скоби, и за всяко число
се слага коментар какво означава.
Първото от тези числа (serial) представлява серийният номер на зоната, който трябва да се увеличава
всеки път, когато нещо в зоналният файл се промени. Изключително важно е това число само да
нараства, и никога да не намалява.
Един от често използваните формати за сериен номер, който показва кога е настъпила последната
промяна в зоналния файл представлява число във вида YYYYMMDDTT, т.е., четири цифри за година,
две цифри за месец, две цифри за дата и още две цифри за поредна промяна в рамките на описания

ден. За последните две цифри (ТТ) има ограничение да са от 00 до 99 (естествено, така не може да има
повече от 100 промени в рамките на един ден).
За удобство приемаме, че конкретен сериен номер (точната поредица цифри) се среща само на едно
място в зоналния файл.
Напишете шел скрипт, който по подадени имена на зонални файлове променя серийният номер в
SOA записа на всеки файл по следният алгоритъм:
• ако датата в серийният номер е по-стара от днешната, новият сериен номер трябва да е от вида
д н е ш н а д а т а 0 0
• ако датата в серийният номер е равна на днешната, серийният номер трябва да се увеличи с
единица
Важат следните условия:
• скриптът трябва да може да обработва и едноредови, и многоредови SOA записи
• за всеки зонален файл, който не е успял да обработи, скриптът трябва да вади съобщение за
грешка, което включва и името на зоналния файл. Съобщенията трябва да са лесно обработваеми
с познатите инструменти за обработка на текст.
Зад. 46 2021-SE-03 Напишете shell скрипт, който приема два позиционни параметъра – имена на файлове.
Примерно извикване:
$ . / f o o . s h i n p u t . b i n o u t p u t . h
Файлът i n p u t . b i n е двоичен файл с елементи u i n t 1 6 _ t числа, създаден на little-endian машина.
Вашият скрипт трябва да генерира C хедър файл, дефиниращ масив с име a r r , който:
• съдържа всички елементи от входния файл;
• няма указана големина;
• не позволява промяна на данните.
Генерираният хедър файл трябва да:
• съдържа и u i n t 3 2 _ t променлива a r r N , която указва големината на масива;
• бъде валиден и да може да се # i n c l u d e -ва без проблеми от C файлове, очакващи да “виждат”
a r r и a r r N .
За да е валиден един входен файл, той трябва да съдържа не повече от 524288 елемента.
За справка, dump на съдържанието на примерен input.bin:
0 0 0 0 0 0 0 0 : 5 5 5 5 5 6 5 5 5 9 5 5 5 a 5 5 6 5 5 5 6 6 5 5 6 9 5 5 6 a 5 5 U U V U Y U Z U e U f U i U j U
0 0 0 0 0 0 1 0 : 9 5 5 5 9 6 5 5 9 9 5 5 9 a 5 5 a 5 5 5 a 6 5 5 a 9 5 5 a a 5 5 . U . U . U . U . U . U . U . U

